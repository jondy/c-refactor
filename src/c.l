%{
  #include <stdio.h>
  #include "c.tab.h"  /* Generated by bison. */

  #define INCREASE_LINENO				\
    yylloc -> first_line ++;				\
    yylloc -> last_line = yylloc -> first_line;

%}

%option 8bit reentrant stack noyywrap
%option bison-bridge bison-locations
%option debug

%x comment linecomment predefine
%s preprocessing preifgroup lparen

INTEGER_SUFFIX       ([uU][lL]?)|([uU](ll|LL)?)|([lL][uU]?)|((ll|LL)[uU]?)
DECIMAL_CONSTANT     [1-9][0-9]*
OCTAL_CONSTANT       0[0-7]*
HEXADECIMAL_CONSTANT 0[xX][0-9A-Fa-f]+

FLOAT_SUFFIX                  [flFL]
DECIMAL_FLOATING_CONSTANT     (([0-9]*[.][0-9]+)|([0-9]*[.]))([eE][-+]?[0-9]+)?
HEXADECIMAL_FLOATING_CONSTANT (([0-9A-Fa-f]*[.][0-9A-Fa-f]+)|([0-9A-Fa-f]*[.]))[pP][-+][0-9]+

SIMPLE_ESCAPE               (\\[\'\"?\\abfnrtv])
OCTAL_ESCAPE_               (\\[0-7]{1,3})
HEXADECIMAL_ESCAPE          (\\[0-9A-Fa-f]+)
UNIVERSAL_CHARACTER_NAME    ((\\u[0-9A-Fa-f]{2})|(\\U[0-9A-Fa-f]{4}))
ESCAPE_SEQUENCE ({SIMPLE_ESCAPE}|(\\[0-7]{1,3})|{HEXADECIMAL_ESCAPE}|{UNIVERSAL_CHARACTER_NAME})

CHARACTER_CONSTANT [L]?\'([^\'\\\n]|{ESCAPE_SEQUENCE})+\'
STRING_LITERAL     [L]?\"([^\"\\\n]|{ESCAPE_SEQUENCE}|(\\\n))*\"
HEADER_NAME        (<[^>\n]*>)|(\"[^\"\n]*\")
PP_NUMBER          [.]?([_0-9A-Za-z]|{UNIVERSAL_CHARACTER_NAME})+([eEpP][-+])|[.]
IDENTIFIER         [_a-zA-Z]([_a-zA-Z0-9]|(\\u[0-9A-Fa-f]{2})|(\\U[0-9A-Fa-f]{4}))*

PREPROCESSING      ^[[:blank:]]*#[[:blank:]]*
PREIFGROUP         (if)|(ifdef)|(ifndef)|(elif)|(else)|(endif)

PUNCTUATOR         [-\[\]\(\)\{\}.&+*~!/%<>^|?:;=,#]
MPUNCTUATOR	   ("+="|"-="|"&="|"^="|"|="|"##"|"<:"|":>"|"<%"|"%>"|"%:"|"->"|"++"|"--"|"<<"|">>"|"<="|">="|"=="|"!="|"&&"|"||"|"*="|"/="|"%="|"<<="|">>="|"%:%:"|"...")

%%

%{
  yy_flex_debug = 0;
%}

<lparen>\(                { *yylval = (YYSTYPE)strdup(yytext);
                            return LPAREN;
			    }

<lparen>\)                { *yylval = (YYSTYPE)strdup(yytext);
                            yy_pop_state(yyscanner);
			    return ')';
                            }

"/*"                      { yy_push_state(comment, yyscanner); }
<comment>"*/"             { yy_pop_state(yyscanner); }
<comment>\n               { INCREASE_LINENO }
<comment>.                { /* do nothing */ }
"//"                      { yy_push_state(linecomment, yyscanner); }
<linecomment>\n           { INCREASE_LINENO
                            yy_pop_state(yyscanner);
		            }
<linecomment>.*           { /* do nothing */ }


<preprocessing>{HEADER_NAME}       { *yylval = (YYSTYPE)strdup(yytext);
                                     return HEADER_NAME;
			             }

<preprocessing>{PP_NUMBER}         { *yylval = (YYSTYPE)strdup(yytext);
                                     return PP_NUMBER;
			             }

{DECIMAL_CONSTANT}{INTEGER_SUFFIX}?     { *yylval = (YYSTYPE)strdup(yytext);
                                          return DECIMAL_CONSTANT;
                                          }

{OCTAL_CONSTANT}{INTEGER_SUFFIX}?       { *yylval = (YYSTYPE)strdup(yytext);
					  return OCTAL_CONSTANT;
                                          }

{HEXADECIMAL_CONSTANT}{INTEGER_SUFFIX}? { *yylval = (YYSTYPE)strdup(yytext);
					  return HEXADECIMAL_CONSTANT;
                                          }

{DECIMAL_FLOATING_CONSTANT}{FLOAT_SUFFIX}?      { *yylval = (YYSTYPE)strdup(yytext);
                                                  return DECIMAL_FLOATING_CONSTANT;
                                                  }

{HEXADECIMAL_FLOATING_CONSTANT}{FLOAT_SUFFIX}?  { *yylval = (YYSTYPE)strdup(yytext);
                                                  return HEXADECIMAL_FLOATING_CONSTANT;
                                                  }

{CHARACTER_CONSTANT}     { *yylval = (YYSTYPE)strdup(yytext);
                           return CHARACTER_CONSTANT;
			   }

{STRING_LITERAL}         { *yylval = (YYSTYPE)strdup(yytext);
                           return STRING_LITERAL;
			   }

{PREPROCESSING}          { yy_push_state(preprocessing, yyscanner);
                           *yylval = (YYSTYPE)strdup(yytext);
			   return '#';
			   }

{PREPROCESSING}{PREIFGROUP}        { *yylval = (YYSTYPE)strdup(strchr(yytext, '#'));
				     yy_push_state(preifgroup, yyscanner);
				     if (strstr(yytext, "ifdef"))
				       return PIFDEF;
				     else if (strstr(yytext, "ifndef"))
				       return PIFNDEF;
				     else if (strstr(yytext, "elif"))
				       return PELIF;
				     else if (strstr(yytext, "else"))
				       return PELSE;
				     else if (strstr(yytext, "endif"))
				       return PENDIF;
				     else
				       return PIF;
                                     }

<predefine>{IDENTIFIER}\(?  {  yy_pop_state(yyscanner);
                               if (strchr(yytext, '(')){
    			         yyless(strlen(yytext) - 1);
                                 *yylval = (YYSTYPE)strdup(yytext);
                                 yy_push_state(lparen, yyscanner);
			       }
			       else
    			         *yylval = (YYSTYPE)strdup(yytext);
			       return IDENTIFIER;
			       }

{IDENTIFIER}              { *yylval = (YYSTYPE)strdup(yytext);
                            if (strcmp(yytext, "auto") == 0) return AUTO;
			    if (strcmp(yytext, "break") == 0) return BREAK;
			    if (strcmp(yytext, "case") == 0) return CASE;
			    if (strcmp(yytext, "char") == 0) return CHAR;
			    if (strcmp(yytext, "const") == 0) return CONST;
			    if (strcmp(yytext, "continue") == 0) return CONTINUE;
			    if (strcmp(yytext, "default") == 0) return DEFAULT;
			    if (strcmp(yytext, "do") == 0) return DO;
			    if (strcmp(yytext, "double") == 0) return DOUBLE;
			    if (strcmp(yytext, "else") == 0) return ELSE;
			    if (strcmp(yytext, "enum") == 0) return ENUM;
			    if (strcmp(yytext, "extern") == 0) return EXTERN;
			    if (strcmp(yytext, "float") == 0) return FLOAT;
			    if (strcmp(yytext, "for") == 0) return FOR;
			    if (strcmp(yytext, "goto") == 0) return GOTO;
			    if (strcmp(yytext, "if") == 0) return IF;
			    if (strcmp(yytext, "inline") == 0) return INLINE;
			    if (strcmp(yytext, "int") == 0) return INT;
			    if (strcmp(yytext, "long") == 0) return LONG;
			    if (strcmp(yytext, "register") == 0) return REGISTER;
			    if (strcmp(yytext, "restrict") == 0) return RESTRICT;
			    if (strcmp(yytext, "return") == 0) return RETURN;
			    if (strcmp(yytext, "short") == 0) return SHORT;
			    if (strcmp(yytext, "signed") == 0) return SIGNED;
			    if (strcmp(yytext, "sizeof") == 0) return SIZEOF;
			    if (strcmp(yytext, "static") == 0) return STATIC;
			    if (strcmp(yytext, "struct") == 0) return STRUCT;
			    if (strcmp(yytext, "switch") == 0) return SWITCH;
			    if (strcmp(yytext, "typedef") == 0) return TYPEDEF;
			    if (strcmp(yytext, "union") == 0) return UNION;
			    if (strcmp(yytext, "unsigned") == 0) return UNSIGNED;
			    if (strcmp(yytext, "void") == 0) return VOID;
			    if (strcmp(yytext, "volatile") == 0) return VOLATILE;
			    if (strcmp(yytext, "while") == 0) return WHILE;
			    if (strcmp(yytext, "_Bool") == 0) return _BOOL;
			    if (strcmp(yytext, "_Complex") == 0) return _COMPLEX;
			    if (strcmp(yytext, "_Imaginary") == 0) return _IMAGINARY;

			    if (strcmp(yytext, "define") == 0){
			      if (YY_START == preprocessing)
				yy_push_state(predefine, yyscanner);
			      return DEFINE;
			    }
			    /*
			    if (strcmp(yytext, "elif") == 0) return ELIF;
			    if (strcmp(yytext, "endif") == 0) return ENDIF;
			    if (strcmp(yytext, "ifdef") == 0) return IFDEF;
			    if (strcmp(yytext, "ifndef") == 0) return IFNDEF;
			    */
			    if (strcmp(yytext, "error") == 0) return ERROR;
			    if (strcmp(yytext, "include") == 0) return INCLUDE;
			    if (strcmp(yytext, "line") == 0) return LINE;
			    if (strcmp(yytext, "pragma") == 0) return PRAGMA;
			    if (strcmp(yytext, "undef") == 0) return UNDEF;

                            /* 如果 yytext 在上下文定义的 typelist 中，那么返回 TYPE_NAME */
                            /* 如果 yytext 在上下文定义的 enumlist 中，那么返回 ENUMERATION_CONSTANT */

			    if (YY_START == preprocessing)
			      return PIDENTIFIER;
			    else {
			      /* 如果在已知的类型定义中 ，那么返回 TYPE_NAME */
                              /* 如果在已知的枚举类型中 ，那么返回 ENUMERATION_CONSTANT */
                              /* ? yyextra == yyget_extra(yyscanner) */
			      PCONTEXT pcontext = (PCONTEXT)yyget_extra(yyscanner);
			      if (pcontext -> findex)
				return TYPE_NAME;
			      else
				return IDENTIFIER;
			    }
                            }

{PUNCTUATOR}             { *yylval = (YYSTYPE)strdup(yytext);
                           return  (YY_START == preprocessing) ? PPUNCTUATOR : *yytext;
                           }

{MPUNCTUATOR}            { *yylval = (YYSTYPE)strdup(yytext);
                           if (YY_START == preprocessing)
			     return PPUNCTUATOR;
			   else if (strcmp(yytext, "+=") == 0)
			     return EQUAL_PLUS;
			   else if (strcmp(yytext, "-=") == 0)
			     return EQUAL_MINUS;
                           else if (strcmp(yytext, "&=") == 0)
			     return EQUAL_AMPERSAND;
                           else if (strcmp(yytext, "^=") == 0)
			     return EQUAL_CARET;
                           else if (strcmp(yytext, "|=") == 0)
			     return EQUAL_VERTICALBAR;
                           else if (strcmp(yytext, "##") == 0)
			     return DOUBLENUMBER;
                           else if (strcmp(yytext, "<:") == 0)
			     return LESSCOLON;
                           else if (strcmp(yytext, ":>") == 0)
			     return COLONGREATER;
                           else if (strcmp(yytext, "<%") == 0)
			     return LESSPERCENT;
                           else if (strcmp(yytext, "%>") == 0)
			     return PERCENTGREATER;
                           else if (strcmp(yytext, "%:") == 0)
			     return PERCENTCOLON;
                           else if (strcmp(yytext, "->") == 0)
			     return HYPHENGREATER;
                           else if (strcmp(yytext, "++") == 0)
			     return DOUBLEPLUS;
                           else if (strcmp(yytext, "--") == 0)
			     return DOUBLEMINUS;
                           else if (strcmp(yytext, "<<") == 0)
			     return DOUBLELESS;
                           else if (strcmp(yytext, ">>") == 0)
			     return DOUBLEGREATER;
                           else if (strcmp(yytext, "<=") == 0)
			     return LESSEQUAL;
                           else if (strcmp(yytext, ">=") == 0)
			     return GREATEREQUAL;
                           else if (strcmp(yytext, "==") == 0)
			     return DOUBLEEQUAL;
                           else if (strcmp(yytext, "!=") == 0)
			     return EXCLAIMEQUAL;
                           else if (strcmp(yytext, "&&") == 0)
			     return DOUBLEAMPERSAND;
                           else if (strcmp(yytext, "||") == 0)
			     return DOUBLEVERTICALBAR;
			   else if (strcmp(yytext, "*=") == 0)
			     return EQUAL_ASTERISK;
			   else if (strcmp(yytext, "/=") == 0)
			     return EQUAL_SLASH;
			   else if (strcmp(yytext, "%=") == 0)
			     return EQUAL_PERCENT;
			   else if (strcmp(yytext, "<<=") == 0)
			     return EQUAL_DOUBLELESS;
                           else if (strcmp(yytext, ">>=") == 0)
			     return EQUAL_DOUBLEGREATER;
                           else if (strcmp(yytext, "%:%:") == 0)
			     return DOUBLEPERCENTCOLON;
                           else if (strcmp(yytext, "...") == 0)
			     return TRIPLEDOT;
			   }

<*>\\\n                   { INCREASE_LINENO } /* ignore the slash at the end of line */

<*>\n                     { INCREASE_LINENO
                            if (YY_START == preprocessing || YY_START == preifgroup){
			      yy_pop_state(yyscanner);
			      *yylval = (YYSTYPE)strdup("\n");
			      return NEW_LINE;
			    }
                            }

<*>[[:blank:]]+           { /* do nothing */ }

<*><<EOF>>                { yypop_buffer_state(yyscanner);
                            if ( !YY_CURRENT_BUFFER ) {
			       yyterminate();
			       }
			    }

<*>.                      { /* ignore all the others */ }

%%

#ifdef DEBUG_FLEX
int main(int argc, char * argv[])
{
  yyscan_t scanner;
  YYSTYPE lvalp;
  YYLTYPE llocp;
  CONTEXT context;

  int token_id = 0;
  FILE * infile;

  ++argv, --argc;  /* skip over program name */
  if (argc > 0) {
    fprintf(stderr, "Open file %s...\n", argv[0]);
    infile = fopen(argv[0], "r");
    if (infile == NULL) {
      fprintf(stderr, "Error when open file '%s'\n", argv[ 0 ]);
      return -1;
    }
  }
  else
      infile = stdin;

  /* infile = fopen("test.c", "r"); */
  /* if (infile == NULL) */
  /*   infile = stdin; */

  fprintf(stdout, "Parsing...\n\n");

  memset(&context, 0, sizeof(CONTEXT));
  memset(&lvalp, 0, sizeof(YYSTYPE));
  memset(&llocp, 0, sizeof(YYLTYPE));
  llocp.first_line = 1;

  yylex_init_extra((YY_EXTRA_TYPE)&context, &scanner);
  yyset_in(infile, scanner);

  token_id = yylex(&lvalp, &llocp, scanner);
  while(token_id) {
    fprintf(stdout,
  	    "Line: %d, Token is %d(%s)\n",
	    llocp.first_line,
  	    token_id,
  	    (char*)lvalp
  	    );
    token_id = yylex(&lvalp, &llocp, scanner);
  }
  yylex_destroy(scanner);

  fprintf(stdout, "Parse end.\n");
  fclose(infile);
  return 0;
}
#endif
